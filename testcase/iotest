let [] (\s \z z) in
let : (\x \xs \s \z s x xs) in
let head (\x x (\a \_ a) _) in
let tail (\x x (\_ \b b) _) in
let empty? (\x x (\_ \_ false) true) in

let pair (\a \b \p p a b) in
let pureIO (\x \s pair s x) in
let putLn (putChar 10) in

let putStr Y(\putStr \s 
    if (empty? s)
      (pureIO NIL)
      (>>
        (putChar (head s))
        (putStr (tail s))
      )
    )
in

let putStrLn (\s >> (putStr s) putLn) in

let helloworld (: 'H' (: 'e' (: 'l' (: 'l' (: 'o' (: ',' (: ' ' (: 'w' (: 'o' (: 'r' (: 'l' (: 'd' (: '!' [])))))))))))))
in

let rev Y(\rev \x \a
    if (empty? x)
      a
      (rev (tail x) (: (head x) a))
    )
in

let reverse (\x rev x []) in

let showInt' Y(\showInt' \i
    if (== 0 i)
      []
      (: (+ '0' (% i 10)) (showInt' (/ i 10)))
    )
in

let showInt (\i
    if (< 0 i)
      (. reverse showInt' i)
      (if (== 0 i)
        (: '0' [])
        (: '-' (. reverse showInt' (* -1 i)))
      )
    )
in

let take Y(\take \n \x
    if (<= n 0)
      []
      (: (head x) (take (- n 1) (tail x)))
    )
in

let map Y(\map \f \x
    if (empty? x)
      []
      (: (f (head x)) (map f (tail x)))
    )
in

let zipWith Y(\zipWith \f \g \h
    if (or (empty? g) (empty? h))
      []
      (: (f (head g) (head h)) (zipWith f (tail g) (tail h)))
    )
in

let fib Y(\fib (: 1 (: 1 (zipWith + fib (tail fib))))) in

let sequence Y(\sequence \x
    if (empty? x)
      (pureIO [])
      (>>= (head x) (\x' (>>= (sequence (tail x)) (\xs' pureIO (: x' xs')))))
    )
in

let main
    (>>
      (putStrLn helloworld)
    (>>
      (putStrLn helloworld)
      let printFibs (sequence (map (. putStrLn showInt) (take 50 fib)))
      in (>> printFibs (>> putLn printFibs))
    )
    )
in

runIO main

