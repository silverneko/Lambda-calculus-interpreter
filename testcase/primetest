:let [] (\s \z z)
:let cons (\x \xs \s \z s x xs)
:let head (\ls ls (\a \_ a) _ )
:let tail (\ls ls (\_ \b b) _ )
:let empty (\ls ls (\_\_ false) true)

:let : cons

:let take Y(\take \n \ls 
    if (== n 0) 
      []
      (: (head ls) (take (- n 1) (tail ls)))
    )

:let map Y(\map \f \ls
    if (empty ls)
      []
      (: (f (head ls)) (map f (tail ls)))
    )

:let zipWith Y(\zipWith \f \xs \ys
    if (or (empty xs) (empty ys))
      []
      (
        let z (f (head xs) (head ys)) $
        let zs (zipWith f (tail xs) (tail ys)) $
          (:  z zs)
      )
    )

:let !! Y(\!! \ls \n
    if (== n 0)
      (head ls)
      (!! (tail ls) (- n 1))
    )

-- pretty print a list
:let pretty-list Y(\pretty-list \ls
    if(empty ls)
      nil
      ((head ls) (pretty-list (tail ls)))
    )

:let filter Y(\filter \siev \ls
    if (empty ls)
      []
      (
        let x (head ls) $
        let xs (tail ls) $
          if (siev x)
            (: x (filter siev xs))
            (filter siev xs)
      )
    )

:let natural-numbers Y(\natural-numbers (: 1 (map (+ 1) natural-numbers)))
:let range Y(\r \a \b if(== a b) (: a []) (: a (r (+ a 1) b)))
:let is-prime (\n
    if(or (== n 0) (== n 1))
      false
      (
        if(== n 2)
          true
          (
            (Y \is-prime \try \n
              if (== n try)
                true
              (
                if (== 0 (% n try))
                  false
                  (is-prime (+ 1 try) n)
              )
            ) 2 n
          )
      )
    )

:let primes Y(\primes
      let is-prime'' (\n (Y\is-prime' \primes
          let p (head primes) (
              if(< n (* p p))
                true
                (if (== 0 (% n p))
                  false
                  (is-prime' (tail primes))
                )
            )
        )
        ) $
      let is-prime (\n is-prime'' n primes) $
          (: 2 (filter is-prime (. tail tail natural-numbers)))
    )

take 1 primes
take 2 primes
take 3 primes
take 4 primes
take 5 primes
take 6 primes

pretty-list (take 100 primes)
-- :let natural-numbers (range 1 1000)
-- pretty-list (take 300 natural-numbers)
-- pretty-list (take 300 (range 1 300))

:let foldr Y(\fr \f \a \l
    if(empty l)
      a
      (f (head l) (fr f a (tail l)))
    )

:let repeat Y(\r \x (: x (r x)))

-- short circuit
foldr * 1 (: 1 (: 2 (: 0 natural-numbers)))
foldr and true (: true (: false (repeat true)))
